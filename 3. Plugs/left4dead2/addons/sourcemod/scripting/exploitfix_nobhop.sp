/*
Exploit Fix - No Bhop
Copyright (C) 2014  Buster "Mr. Zero" Nielsen

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#pragma semicolon 1
#pragma newdecls required

/* Includes */
#include <sourcemod>
#include <sdktools>

/* Plugin Information */
public Plugin myinfo = 
{
	name		= "Exploit Fix - No Bhop",
	author		= "Buster \"Mr. Zero\" Nielsen",
	description	= "Stops players from bunny hopping",
	version		= "1.0.0",
	url		= "mrzerodk@gmail.com"
}

/* Globals */
#define PLUGIN_VERSION "1.0"
#define CVAR_FLAGS FCVAR_NOTIFY
#define DEBUG 0
#define DEBUG_TAG "ExploitFix_NoBhop"
#define MAXENTITIES 2048
#define MAXEDICTS 4096

ConVar hPluginOn;
static float leftGroundMaxSpeed[MAXPLAYERS + 1] = {0.0, ...}, curVelVec[3];
bool bHooked = false, g_IsInGame[MAXPLAYERS + 1] = {false, ...}, g_IsBot[MAXPLAYERS + 1] = {false, ...}, g_IsAlive[MAXPLAYERS + 1] = {false, ...};
int g_Team[MAXPLAYERS + 1] = {0, ...};

/* Plugin Functions */
public void OnPluginStart()
{
	CreateConVar("l4d2_exploitfix_nb_version", PLUGIN_VERSION, "Version of the Exploit Fix - No Bhop plugin.", CVAR_FLAGS|FCVAR_SPONLY|FCVAR_DONTRECORD);
	hPluginOn = CreateConVar("l4d2_exploitfix_nb_plugin_on", "1", "Plugin On/Off.", CVAR_FLAGS);
	hPluginOn.AddChangeHook(OnConVarChanged_Allow);
	AutoExecConfig(true, "l4d2_exploitfix_nb");
}

public void OnConfigsExecuted()
{
	IsAllowed();
}

void OnConVarChanged_Allow(ConVar cvar, const char[] sOldValue, const char[] sNewValue)
{
	IsAllowed();
}

void IsAllowed()
{
	bool bPluginOn = hPluginOn.BoolValue;
	if(bPluginOn && !bHooked)
	{
		bHooked = true;
		HookEvent("player_spawn", PlayerStateChange_Event);
		HookEvent("player_death", PlayerStateChange_Event);
		HookEvent("player_team", PlayerStateChange_Event);
	}
	else if(!bPluginOn && bHooked)
	{
		bHooked = false;
		UnhookEvent("player_spawn", PlayerStateChange_Event);
		UnhookEvent("player_death", PlayerStateChange_Event);
		UnhookEvent("player_team", PlayerStateChange_Event);
	}
}

void PlayerStateChange_Event(Event event, const char[] name, bool dontBroadcast)
{
	int client = GetClientOfUserId(event.GetInt("userid"));
	if (client > 0 && client <= MaxClients && g_IsInGame[client])
	{
		#if DEBUG
		Debug_PrintText("Event \"%s\"", name)
		Debug_PrintText(" - Player  = %N (%d)", client, client);
		#endif

		if (StrEqual(name, "player_team"))
		{
			g_Team[client] = event.GetInt("team");
			g_IsAlive[client] = false;
		}
		else
		{
			g_IsAlive[client] = IsPlayerAlive(client);
		}
		#if DEBUG
		Debug_PrintText(" - Team    = %d", g_Team[client]);
		Debug_PrintText(" - IsAlive = %b", g_IsAlive[client]);
		#endif
	}
}

public void OnAllPluginsLoaded()
{
	for (int client = 1; client <= MaxClients; client++)
	{
		if (IsClientInGame(client))
		{
			g_IsInGame[client] = true;
			g_IsBot[client] = IsFakeClient(client);
			g_IsAlive[client] = IsPlayerAlive(client);
			g_Team[client] = GetClientTeam(client);
		}
	}
}

public void OnClientPutInServer(int client)
{
	if (client > 0 && bHooked)
	{
		g_IsInGame[client] = true;
		g_IsBot[client] = IsFakeClient(client);
	}
}

public void OnClientDisconnect(int client)
{
	if (client > 0 && bHooked)
	{
		g_IsInGame[client] = false;
		g_IsBot[client] = false;
		g_IsAlive[client] = false;
		g_Team[client] = 0;
	}
}
public Action OnPlayerRunCmd(int client, int &buttons, int &impulse, float vel[3], float angles[3], int &weapon)
{	
	if (g_IsInGame[client] && !g_IsBot[client] && g_IsAlive[client] && GetEntityFlags(client) & FL_ONGROUND)
	{
		if (leftGroundMaxSpeed[client] != -1.0)
		{
			GetEntPropVector(client, Prop_Data, "m_vecAbsVelocity", curVelVec);
			if (GetVectorLength(curVelVec) > leftGroundMaxSpeed[client])
			{
				#if DEBUG
				Debug_PrintText("%N Speed: %f (%.2f %.2f %.2f), MaxSpeed %f", client, GetVectorLength(curVelVec), curVelVec[0], curVelVec[1], curVelVec[2], leftGroundMaxSpeed[client]);
				#endif
				NormalizeVector(curVelVec, curVelVec);
				ScaleVector(curVelVec, leftGroundMaxSpeed[client]);
				TeleportEntity(client, NULL_VECTOR, NULL_VECTOR, curVelVec);
			}
			leftGroundMaxSpeed[client] = -1.0;
		}
		else
		{
			leftGroundMaxSpeed[client] = GetEntPropFloat(client, Prop_Data, "m_flMaxspeed");
		}
	}
	return Plugin_Continue;
}

#if DEBUG
stock void Debug_PrintText(const char[] format, any ...)
{
	char buffer[256];
	VFormat(buffer, sizeof(buffer), format, 2);
	LogMessage(buffer);

	for (int client = 1; client <= MaxClients; client++)
	{
		if (IsClientInGame(client) && !IsFakeClient(client))
		{
			adminId = GetUserAdmin(client)
			if (adminId != INVALID_ADMIN_ID && GetAdminFlag(adminId, Admin_Root))
			{
				PrintToChat(client, "[%s] %s", DEBUG_TAG, buffer);
			}
		}
	}
}
#endif
